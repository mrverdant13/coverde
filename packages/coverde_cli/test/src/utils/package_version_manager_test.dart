import 'package:coverde/src/entities/entities.dart';
import 'package:coverde/src/utils/utils.dart';
import 'package:http/http.dart' as http;
import 'package:io/ansi.dart';
import 'package:mason_logger/mason_logger.dart';
import 'package:mocktail/mocktail.dart';
import 'package:path/path.dart' as p;
import 'package:pub_semver/pub_semver.dart';
import 'package:test/test.dart';
import 'package:universal_io/universal_io.dart';
import 'package:yaml/yaml.dart';

class _MockHttpClient extends Mock implements http.Client {}

final class _MockPackageVersionManagerDependencies extends Mock
    implements PackageVersionManagerDependencies {}

final class _MockLogger extends Mock implements Logger {}

final class _MockProgress extends Mock implements Progress {}

void main() {
  setUpAll(() {
    registerFallbackValue(Uri.parse(''));
  });

  group('$PackageVersionManager', () {
    late PackageVersionManagerDependencies dependencies;
    late PackageVersionManager packageVersionManager;

    setUp(() {
      dependencies = _MockPackageVersionManagerDependencies();
      packageVersionManager = PackageVersionManager(
        dependencies: dependencies,
      );
    });

    test('can be instantiated', () {
      expect(packageVersionManager, isA<PackageVersionManager>());
    });

    group('getGlobalPackageInstallationInfo', () {
      setUp(() {
        when(() => dependencies.baseUrl).thenReturn('https://pub.dev');
      });

      test(
          'throws an $AbsentGlobalLockFileForGlobalInstallationFailure '
          'if the lock file path resolves to a non-existent entity', () async {
        final tempDir = Directory.systemTemp.createTempSync();
        addTearDown(() => tempDir.deleteSync(recursive: true));
        when(() => dependencies.globalLockFilePath)
            .thenReturn(p.join(tempDir.path, 'pubspec.lock'));
        Future<void> action() async =>
            packageVersionManager.getGlobalPackageInstallationInfo();
        expect(
          action,
          throwsA(isA<AbsentGlobalLockFileForGlobalInstallationFailure>()),
        );
      });

      test(
          'throws an $AbsentGlobalLockFileForGlobalInstallationFailure '
          'if the lock file path resolves to a non-file entity', () async {
        final tempDir = Directory.systemTemp.createTempSync();
        addTearDown(() => tempDir.deleteSync(recursive: true));
        when(() => dependencies.globalLockFilePath).thenReturn(tempDir.path);
        Future<void> action() async =>
            packageVersionManager.getGlobalPackageInstallationInfo();
        expect(
          action,
          throwsA(isA<AbsentGlobalLockFileForGlobalInstallationFailure>()),
        );
      });

      test(
          'throws an $InvalidGlobalLockMemberTypeForGlobalInstallationFailure '
          'if the lock file content root is not a $YamlMap', () async {
        final tempDir = Directory.systemTemp.createTempSync();
        addTearDown(() => tempDir.deleteSync(recursive: true));
        final lockFilePath = p.join(tempDir.path, 'pubspec.lock');
        File(lockFilePath).writeAsStringSync('''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
12345
''');
        when(() => dependencies.globalLockFilePath).thenReturn(lockFilePath);
        Future<void> action() async =>
            packageVersionManager.getGlobalPackageInstallationInfo();
        expect(
          action,
          throwsA(
            isA<InvalidGlobalLockMemberTypeForGlobalInstallationFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  isNull,
                )
                .having(
                  (failure) => failure.expectedType,
                  'expectedType',
                  YamlMap,
                ),
          ),
        );
      });

      test(
          'throws an $InvalidGlobalLockMemberTypeForGlobalInstallationFailure '
          'if the lock file content "packages" member is not a $YamlMap',
          () async {
        final tempDir = Directory.systemTemp.createTempSync();
        addTearDown(() => tempDir.deleteSync(recursive: true));
        final lockFilePath = p.join(tempDir.path, 'pubspec.lock');
        File(lockFilePath).writeAsStringSync('''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  12345
''');
        when(() => dependencies.globalLockFilePath).thenReturn(lockFilePath);
        Future<void> action() async =>
            packageVersionManager.getGlobalPackageInstallationInfo();
        expect(
          action,
          throwsA(
            isA<InvalidGlobalLockMemberTypeForGlobalInstallationFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  'packages',
                )
                .having(
                  (failure) => failure.expectedType,
                  'expectedType',
                  YamlMap,
                ),
          ),
        );
      });

      test(
          'throws an $InvalidGlobalLockMemberTypeForGlobalInstallationFailure '
          'if the lock file content "packages" member values '
          'are not ${YamlMap}s', () async {
        final tempDir = Directory.systemTemp.createTempSync();
        addTearDown(() => tempDir.deleteSync(recursive: true));
        final lockFilePath = p.join(tempDir.path, 'pubspec.lock');
        File(lockFilePath).writeAsStringSync('''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  p1: 12345
  p2: 67890
''');
        when(() => dependencies.globalLockFilePath).thenReturn(lockFilePath);
        Future<void> action() async =>
            packageVersionManager.getGlobalPackageInstallationInfo();
        expect(
          action,
          throwsA(
            isA<InvalidGlobalLockMemberTypeForGlobalInstallationFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  'packages(values)',
                )
                .having(
                  (failure) => failure.expectedType,
                  'expectedType',
                  Iterable<YamlMap>,
                ),
          ),
        );
      });

      test(
          'throws an $NoDirectMainHostedPackageForGlobalInstallationFailure '
          'if the lock file does not contain the main package lock entry',
          () async {
        final tempDir = Directory.systemTemp.createTempSync();
        addTearDown(() => tempDir.deleteSync(recursive: true));
        final lockFilePath = p.join(tempDir.path, 'pubspec.lock');
        File(lockFilePath).writeAsStringSync('''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  p1:
    dependency: transitive
    description:
      name: p1
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  p2:
    dependency: transitive
    description:
      name: p2
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
sdks:
  dart: ">=3.6.0 <4.0.0"
''');
        when(() => dependencies.globalLockFilePath).thenReturn(lockFilePath);
        Future<void> action() async =>
            packageVersionManager.getGlobalPackageInstallationInfo();
        expect(
          action,
          throwsA(
            isA<NoDirectMainHostedPackageForGlobalInstallationFailure>(),
          ),
        );
      });

      test(
          'throws an $InvalidGlobalLockMemberTypeForGlobalInstallationFailure '
          'if the lock file direct main hosted package '
          'description is not a $YamlMap', () async {
        final tempDir = Directory.systemTemp.createTempSync();
        addTearDown(() => tempDir.deleteSync(recursive: true));
        final lockFilePath = p.join(tempDir.path, 'pubspec.lock');
        File(lockFilePath).writeAsStringSync('''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  p1:
    dependency: transitive
    description:
      name: p1
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  coverde:
    dependency: "direct main"
    description: 12345
    source: hosted
    version: "0.2.0+1"
  p2:
    dependency: transitive
    description:
      name: p2
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
''');
        when(() => dependencies.globalLockFilePath).thenReturn(lockFilePath);
        Future<void> action() async =>
            packageVersionManager.getGlobalPackageInstallationInfo();
        expect(
          action,
          throwsA(
            isA<InvalidGlobalLockMemberTypeForGlobalInstallationFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  [
                    'packages',
                    '["dependency"="direct main", "source"="hosted"]',
                    'description',
                  ].join('.'),
                )
                .having(
                  (failure) => failure.expectedType,
                  'expectedType',
                  YamlMap,
                ),
          ),
        );
      });

      test(
          'throws an $InvalidGlobalLockMemberTypeForGlobalInstallationFailure '
          'if the lock file direct main hosted package '
          'description name is not a $String', () async {
        final tempDir = Directory.systemTemp.createTempSync();
        addTearDown(() => tempDir.deleteSync(recursive: true));
        final lockFilePath = p.join(tempDir.path, 'pubspec.lock');
        File(lockFilePath).writeAsStringSync('''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  p1:
    dependency: transitive
    description:
      name: p1
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  coverde:
    dependency: "direct main"
    description:
      name: 123
      url: "https://pub.dev"
    source: hosted
    version: "0.2.0+1"
  p2:
    dependency: transitive
    description:
      name: p2
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
''');
        when(() => dependencies.globalLockFilePath).thenReturn(lockFilePath);
        Future<void> action() async =>
            packageVersionManager.getGlobalPackageInstallationInfo();
        expect(
          action,
          throwsA(
            isA<InvalidGlobalLockMemberTypeForGlobalInstallationFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  [
                    'packages',
                    '["dependency"="direct main", "source"="hosted"]',
                    'description',
                    'name',
                  ].join('.'),
                )
                .having(
                  (failure) => failure.expectedType,
                  'expectedType',
                  String,
                ),
          ),
        );
      });

      test(
          'throws an $InvalidGlobalLockMemberTypeForGlobalInstallationFailure '
          'if the lock file direct main hosted package '
          'description url is not a $String', () async {
        final tempDir = Directory.systemTemp.createTempSync();
        addTearDown(() => tempDir.deleteSync(recursive: true));
        final lockFilePath = p.join(tempDir.path, 'pubspec.lock');
        File(lockFilePath).writeAsStringSync('''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  p1:
    dependency: transitive
    description:
      name: p1
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  coverde:
    dependency: "direct main"
    description:
      name: coverde
      url: 123
    source: hosted
    version: "0.2.0+1"
  p2:
    dependency: transitive
    description:
      name: p2
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
''');
        when(() => dependencies.globalLockFilePath).thenReturn(lockFilePath);
        Future<void> action() async =>
            packageVersionManager.getGlobalPackageInstallationInfo();
        expect(
          action,
          throwsA(
            isA<InvalidGlobalLockMemberTypeForGlobalInstallationFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  [
                    'packages',
                    '["dependency"="direct main", "source"="hosted"]',
                    'description',
                    'url',
                  ].join('.'),
                )
                .having(
                  (failure) => failure.expectedType,
                  'expectedType',
                  String,
                ),
          ),
        );
      });

      test(
          'throws an $InvalidGlobalLockMemberTypeForGlobalInstallationFailure '
          'if the lock file direct main hosted package '
          'description url is not a valid URL', () async {
        final tempDir = Directory.systemTemp.createTempSync();
        addTearDown(() => tempDir.deleteSync(recursive: true));
        final lockFilePath = p.join(tempDir.path, 'pubspec.lock');
        File(lockFilePath).writeAsStringSync('''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  p1:
    dependency: transitive
    description:
      name: p1
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  coverde:
    dependency: "direct main"
    description:
      name: coverde
      url: "https://invalid.com"
    source: hosted
    version: "0.2.0+1"
  p2:
    dependency: transitive
    description:
      name: p2
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
''');
        when(() => dependencies.globalLockFilePath).thenReturn(lockFilePath);
        Future<void> action() async =>
            packageVersionManager.getGlobalPackageInstallationInfo();
        expect(
          action,
          throwsA(
            isA<InvalidGlobalLockMemberValueForGlobalInstallationFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  [
                    'packages',
                    '["dependency"="direct main", "source"="hosted"]',
                    'description',
                    'url',
                  ].join('.'),
                )
                .having(
                  (failure) => failure.hint,
                  'hint',
                  'equal to https://pub.dev',
                ),
          ),
        );
      });

      test(
          'throws an $InvalidGlobalLockMemberTypeForGlobalInstallationFailure '
          'if the lock file direct main hosted package '
          'version is not a $String', () async {
        final tempDir = Directory.systemTemp.createTempSync();
        addTearDown(() => tempDir.deleteSync(recursive: true));
        final lockFilePath = p.join(tempDir.path, 'pubspec.lock');
        File(lockFilePath).writeAsStringSync('''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  p1:
    dependency: transitive
    description:
      name: p1
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  coverde:
    dependency: "direct main"
    description:
      name: coverde
      url: "https://pub.dev"
    source: hosted
    version: 12345
  p2:
    dependency: transitive
    description:
      name: p2
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
''');
        when(() => dependencies.globalLockFilePath).thenReturn(lockFilePath);
        Future<void> action() async =>
            packageVersionManager.getGlobalPackageInstallationInfo();
        expect(
          action,
          throwsA(
            isA<InvalidGlobalLockMemberTypeForGlobalInstallationFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  [
                    'packages',
                    '["dependency"="direct main", "source"="hosted"]',
                    'version',
                  ].join('.'),
                )
                .having(
                  (failure) => failure.expectedType,
                  'expectedType',
                  String,
                ),
          ),
        );
      });

      test(
          'throws an $InvalidGlobalLockMemberTypeForGlobalInstallationFailure '
          'if the lock file direct main hosted package '
          'version is not a valid SemVer string', () async {
        final tempDir = Directory.systemTemp.createTempSync();
        addTearDown(() => tempDir.deleteSync(recursive: true));
        final lockFilePath = p.join(tempDir.path, 'pubspec.lock');
        File(lockFilePath).writeAsStringSync('''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  p1:
    dependency: transitive
    description:
      name: p1
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  coverde:
    dependency: "direct main"
    description:
      name: coverde
      url: "https://pub.dev"
    source: hosted
    version: "invalid"
  p2:
    dependency: transitive
    description:
      name: p2
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
''');
        when(() => dependencies.globalLockFilePath).thenReturn(lockFilePath);
        Future<void> action() async =>
            packageVersionManager.getGlobalPackageInstallationInfo();
        expect(
          action,
          throwsA(
            isA<InvalidGlobalLockMemberValueForGlobalInstallationFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  [
                    'packages',
                    '["dependency"="direct main", "source"="hosted"]',
                    'version',
                  ].join('.'),
                )
                .having(
                  (failure) => failure.hint,
                  'hint',
                  'a valid SemVer string',
                ),
          ),
        );
      });

      test(
          'throws an $InvalidGlobalLockMemberTypeForGlobalInstallationFailure '
          'if the lock file does not contain the SDKs version constraints',
          () async {
        final tempDir = Directory.systemTemp.createTempSync();
        addTearDown(() => tempDir.deleteSync(recursive: true));
        final lockFilePath = p.join(tempDir.path, 'pubspec.lock');
        File(lockFilePath).writeAsStringSync('''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  p1:
    dependency: transitive
    description:
      name: p1
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  coverde:
    dependency: "direct main"
    description:
      name: coverde
      url: "https://pub.dev"
    source: hosted
    version: "0.2.0+1"
  p2:
    dependency: transitive
    description:
      name: p2
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
''');
        when(() => dependencies.globalLockFilePath).thenReturn(lockFilePath);
        Future<void> action() async =>
            packageVersionManager.getGlobalPackageInstallationInfo();
        expect(
          action,
          throwsA(
            isA<InvalidGlobalLockMemberTypeForGlobalInstallationFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  'sdks',
                )
                .having(
                  (failure) => failure.expectedType,
                  'expectedType',
                  YamlMap,
                ),
          ),
        );
      });

      test(
          'throws an $InvalidGlobalLockMemberTypeForGlobalInstallationFailure '
          'if the lock file does not contain the Dart SDK version constraints',
          () async {
        final tempDir = Directory.systemTemp.createTempSync();
        addTearDown(() => tempDir.deleteSync(recursive: true));
        final lockFilePath = p.join(tempDir.path, 'pubspec.lock');
        File(lockFilePath).writeAsStringSync('''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  p1:
    dependency: transitive
    description:
      name: p1
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  coverde:
    dependency: "direct main"
    description:
      name: coverde
      url: "https://pub.dev"
    source: hosted
    version: "0.2.0+1"
  p2:
    dependency: transitive
    description:
      name: p2
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
sdks:
  other: ">=3.6.0 <4.0.0"
''');
        when(() => dependencies.globalLockFilePath).thenReturn(lockFilePath);
        Future<void> action() async =>
            packageVersionManager.getGlobalPackageInstallationInfo();
        expect(
          action,
          throwsA(
            isA<InvalidGlobalLockMemberTypeForGlobalInstallationFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  'sdks.dart',
                )
                .having(
                  (failure) => failure.expectedType,
                  'expectedType',
                  String,
                ),
          ),
        );
      });

      test(
          'throws an $InvalidGlobalLockMemberValueForGlobalInstallationFailure '
          'if the lock file contains invalid Dart SDK version constraints',
          () async {
        final tempDir = Directory.systemTemp.createTempSync();
        addTearDown(() => tempDir.deleteSync(recursive: true));
        final lockFilePath = p.join(tempDir.path, 'pubspec.lock');
        File(lockFilePath).writeAsStringSync('''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  p1:
    dependency: transitive
    description:
      name: p1
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  coverde:
    dependency: "direct main"
    description:
      name: coverde
      url: "https://pub.dev"
    source: hosted
    version: "0.2.0+1"
  p2:
    dependency: transitive
    description:
      name: p2
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
sdks:
  dart: ">=3.6.0 asdf <4.0.0"
''');
        when(() => dependencies.globalLockFilePath).thenReturn(lockFilePath);
        Future<void> action() async =>
            packageVersionManager.getGlobalPackageInstallationInfo();
        expect(
          action,
          throwsA(
            isA<InvalidGlobalLockMemberValueForGlobalInstallationFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  'sdks.dart',
                )
                .having(
                  (failure) => failure.hint,
                  'hint',
                  'a valid SemVer constraint string',
                ),
          ),
        );
      });

      test('returns the global package installation info ', () async {
        final tempDir = Directory.systemTemp.createTempSync();
        addTearDown(() => tempDir.deleteSync(recursive: true));
        final lockFilePath = p.join(tempDir.path, 'pubspec.lock');
        File(lockFilePath).writeAsStringSync('''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  p1:
    dependency: transitive
    description:
      name: p1
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  coverde:
    dependency: "direct main"
    description:
      name: coverde
      url: "https://pub.dev"
    source: hosted
    version: "0.2.0+1"
  p2:
    dependency: transitive
    description:
      name: p2
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
sdks:
  dart: ">=3.6.0 <4.0.0"
''');
        when(() => dependencies.globalLockFilePath).thenReturn(lockFilePath);
        final globalPackageInstallationInfo =
            await packageVersionManager.getGlobalPackageInstallationInfo();
        expect(
          globalPackageInstallationInfo,
          PackageVersioningInfo(
            packageName: 'coverde',
            packageVersion: Version.parse('0.2.0+1'),
            dartVersionConstraint: VersionConstraint.parse('>=3.6.0 <4.0.0'),
          ),
        );
      });
    });

    group('getRemotePackageVersioningInfos', () {
      late http.Client httpClient;

      setUp(() {
        httpClient = _MockHttpClient();
        when(() => dependencies.httpClient).thenReturn(httpClient);
        when(() => dependencies.baseUrl).thenReturn('https://example.com');
      });

      test(
          'throws an $UnexpectedRemotePackageVersioningInfosRetrievalFailure '
          'if the remote package info request fails', () async {
        when(() => httpClient.get(any()))
            .thenThrow(Exception('Failed to get remote package info'));
        expect(
          () =>
              packageVersionManager.getRemotePackageVersioningInfos('coverde'),
          throwsA(
            isA<UnexpectedRemotePackageVersioningInfosRetrievalFailure>(),
          ),
        );
      });

      test(
          'throws an $UnexpectedRemotePackageVersioningInfosRetrievalFailure '
          'if the remote package info response is not ${HttpStatus.ok}',
          () async {
        when(() => httpClient.get(any()))
            .thenAnswer((_) async => http.Response('Not Found', 404));
        expect(
          () =>
              packageVersionManager.getRemotePackageVersioningInfos('coverde'),
          throwsA(
            isA<UnexpectedRemotePackageVersioningInfosRetrievalFailure>(),
          ),
        );
      });

      test(
          'throws an $InvalidRemotePackageVersioningInfoMemberValueFailure '
          'if the remote package info response is not a valid JSON string',
          () async {
        when(() => httpClient.get(any())).thenAnswer(
          (_) async => http.Response(
            '{',
            HttpStatus.ok,
          ),
        );
        expect(
          () =>
              packageVersionManager.getRemotePackageVersioningInfos('coverde'),
          throwsA(
            isA<InvalidRemotePackageVersioningInfoMemberValueFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  null,
                )
                .having(
                  (failure) => failure.hint,
                  'hint',
                  'a valid JSON string',
                ),
          ),
        );
      });

      test(
          'throws an $InvalidRemotePackageVersioningInfoMemberTypeFailure '
          'if the remote package info response is not a '
          '${Map<String, dynamic>}', () async {
        when(() => httpClient.get(any())).thenAnswer(
          (_) async => http.Response(
            '"Not a map"',
            HttpStatus.ok,
          ),
        );
        expect(
          () =>
              packageVersionManager.getRemotePackageVersioningInfos('coverde'),
          throwsA(
            isA<InvalidRemotePackageVersioningInfoMemberTypeFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  null,
                )
                .having(
                  (failure) => failure.expectedType,
                  'expectedType',
                  Map<String, dynamic>,
                ),
          ),
        );
      });

      test(
          'throws an $InvalidRemotePackageVersioningInfoMemberTypeFailure '
          'if the remote package info response "versions" member is not a '
          '$List', () async {
        when(() => httpClient.get(any())).thenAnswer(
          (_) async => http.Response(
            '{"versions": "Not a Map"}',
            HttpStatus.ok,
          ),
        );
        expect(
          () =>
              packageVersionManager.getRemotePackageVersioningInfos('coverde'),
          throwsA(
            isA<InvalidRemotePackageVersioningInfoMemberTypeFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  'versions',
                )
                .having(
                  (failure) => failure.expectedType,
                  'expectedType',
                  List,
                ),
          ),
        );
      });

      test(
          'throws an $InvalidRemotePackageVersioningInfoMemberTypeFailure '
          'if the remote package info response "versions" member contains an '
          'item that is not a ${Map<String, dynamic>}', () async {
        when(() => httpClient.get(any())).thenAnswer(
          (_) async => http.Response(
            '{"versions": [1, 2, 3]}',
            HttpStatus.ok,
          ),
        );
        expect(
          () =>
              packageVersionManager.getRemotePackageVersioningInfos('coverde'),
          throwsA(
            isA<InvalidRemotePackageVersioningInfoMemberTypeFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  'versions.[0]',
                )
                .having(
                  (failure) => failure.expectedType,
                  'expectedType',
                  Map<String, dynamic>,
                ),
          ),
        );
      });

      test(
          'throws an $InvalidRemotePackageVersioningInfoMemberTypeFailure '
          'if the remote package info response "versions.<index>.version" '
          'member that is not a $String', () async {
        when(() => httpClient.get(any())).thenAnswer(
          (_) async => http.Response(
            '{"versions": [{"version": 123}]}',
            HttpStatus.ok,
          ),
        );
        expect(
          () =>
              packageVersionManager.getRemotePackageVersioningInfos('coverde'),
          throwsA(
            isA<InvalidRemotePackageVersioningInfoMemberTypeFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  'versions.[0].version',
                )
                .having(
                  (failure) => failure.expectedType,
                  'expectedType',
                  String,
                ),
          ),
        );
      });

      test(
          'throws an $InvalidRemotePackageVersioningInfoMemberValueFailure '
          'if the remote package info response "versions.<index>.version" '
          'member is not a valid SemVer string', () async {
        when(() => httpClient.get(any())).thenAnswer(
          (_) async => http.Response(
            '{"versions": [{"version": "invalid"}]}',
            HttpStatus.ok,
          ),
        );
        expect(
          () =>
              packageVersionManager.getRemotePackageVersioningInfos('coverde'),
          throwsA(
            isA<InvalidRemotePackageVersioningInfoMemberValueFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  'versions.[0].version',
                )
                .having(
                  (failure) => failure.hint,
                  'hint',
                  'a valid SemVer string',
                ),
          ),
        );
      });

      test(
          'throws an $InvalidRemotePackageVersioningInfoMemberTypeFailure '
          'if the remote package info response "versions.<index>.pubspec" '
          'member is not a ${Map<String, dynamic>}', () async {
        when(() => httpClient.get(any())).thenAnswer(
          (_) async => http.Response(
            '''
{
  "versions": [
    {
      "version": "0.1.0",
      "pubspec": "Not a Map"
    }
  ]
}
''',
            HttpStatus.ok,
          ),
        );
        expect(
          () =>
              packageVersionManager.getRemotePackageVersioningInfos('coverde'),
          throwsA(
            isA<InvalidRemotePackageVersioningInfoMemberTypeFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  'versions.[0].pubspec',
                )
                .having(
                  (failure) => failure.expectedType,
                  'expectedType',
                  Map<String, dynamic>,
                ),
          ),
        );
      });

      test(
          'throws an $InvalidRemotePackageVersioningInfoMemberTypeFailure '
          'if the remote package info response '
          '"versions.<index>.pubspec.environment" member is not a '
          '${Map<String, dynamic>}', () async {
        when(() => httpClient.get(any())).thenAnswer(
          (_) async => http.Response(
            '''
{
  "versions": [
    {
      "version": "0.1.0",
      "pubspec": {
        "environment": "Not a Map"
      }
    }
  ]
}
''',
            HttpStatus.ok,
          ),
        );
        expect(
          () =>
              packageVersionManager.getRemotePackageVersioningInfos('coverde'),
          throwsA(
            isA<InvalidRemotePackageVersioningInfoMemberTypeFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  'versions.[0].pubspec.environment',
                )
                .having(
                  (failure) => failure.expectedType,
                  'expectedType',
                  Map<String, dynamic>,
                ),
          ),
        );
      });

      test(
          'throws an $InvalidRemotePackageVersioningInfoMemberTypeFailure '
          'if the remote package info response '
          '"versions.<index>.pubspec.environment.sdk" member is not a '
          '$String', () async {
        when(() => httpClient.get(any())).thenAnswer(
          (_) async => http.Response(
            '''
{
  "versions": [
    {
      "version": "0.1.0",
      "pubspec": {
        "environment": {
          "sdk": 123
        }
      }
    }
  ]
}
''',
            HttpStatus.ok,
          ),
        );
        expect(
          () =>
              packageVersionManager.getRemotePackageVersioningInfos('coverde'),
          throwsA(
            isA<InvalidRemotePackageVersioningInfoMemberTypeFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  'versions.[0].pubspec.environment.sdk',
                )
                .having(
                  (failure) => failure.expectedType,
                  'expectedType',
                  String,
                ),
          ),
        );
      });

      test(
          'throws an $InvalidRemotePackageVersioningInfoMemberValueFailure '
          'if the remote package info response '
          '"versions.<index>.pubspec.environment.sdk" member is not a '
          'valid SemVer constraint string', () async {
        when(() => httpClient.get(any())).thenAnswer(
          (_) async => http.Response(
            '''
{
  "versions": [
    {
      "version": "0.1.0",
      "pubspec": {
        "environment": {
          "sdk": "invalid"
        }
      }
    }
  ]
}
''',
            HttpStatus.ok,
          ),
        );
        expect(
          () =>
              packageVersionManager.getRemotePackageVersioningInfos('coverde'),
          throwsA(
            isA<InvalidRemotePackageVersioningInfoMemberValueFailure>()
                .having(
                  (failure) => failure.key,
                  'key',
                  'versions.[0].pubspec.environment.sdk',
                )
                .having(
                  (failure) => failure.hint,
                  'hint',
                  'a valid SemVer constraint string',
                ),
          ),
        );
      });

      test('returns the remote package installation infos', () async {
        when(() => httpClient.get(any())).thenAnswer(
          (_) async => http.Response(
            '''
{
  "name": "coverde",
  "versions": [
    {
      "version": "0.1.0",
      "pubspec": {
        "environment": {
          "sdk": ">=2.14.4 <3.0.0"
        }
      }
    },
    {
      "version": "0.1.0+1",
      "pubspec": {
        "environment": {
          "sdk": ">=2.14.4 <3.0.0"
        }
      }
    },
    {
      "version": "0.2.0",
      "retracted": true,
      "pubspec": {
        "environment": {
          "sdk": ">=3.0.0 <4.0.0"
        }
      }
    },
    {
      "version": "0.2.0+1",
      "retracted": true,
      "pubspec": {
        "environment": {
          "sdk": ">=3.0.0 <4.0.0"
        }
      }
    },
    {
      "version": "0.2.0+2",
      "pubspec": {
        "environment": {
          "sdk": ">=3.0.0 <4.0.0"
        }
      }
    }
  ]
}
            ''',
            HttpStatus.ok,
          ),
        );
        final remotePackageInstallationInfos = await packageVersionManager
            .getRemotePackageVersioningInfos('coverde');
        expect(
          remotePackageInstallationInfos,
          [
            PackageVersioningInfo(
              packageName: 'coverde',
              packageVersion: Version.parse('0.2.0+2'),
              dartVersionConstraint: VersionConstraint.parse('>=3.0.0 <4.0.0'),
            ),
            PackageVersioningInfo(
              packageName: 'coverde',
              packageVersion: Version.parse('0.2.0+1'),
              dartVersionConstraint: VersionConstraint.parse('>=3.0.0 <4.0.0'),
            ),
            PackageVersioningInfo(
              packageName: 'coverde',
              packageVersion: Version.parse('0.2.0'),
              dartVersionConstraint: VersionConstraint.parse('>=3.0.0 <4.0.0'),
            ),
            PackageVersioningInfo(
              packageName: 'coverde',
              packageVersion: Version.parse('0.1.0+1'),
              dartVersionConstraint: VersionConstraint.parse('>=2.14.4 <3.0.0'),
            ),
            PackageVersioningInfo(
              packageName: 'coverde',
              packageVersion: Version.parse('0.1.0'),
              dartVersionConstraint: VersionConstraint.parse('>=2.14.4 <3.0.0'),
            ),
          ],
        );
      });
    });

    group('promptUpdate', () {
      late String lockFilePath;
      late http.Client httpClient;
      late Logger logger;

      setUp(() {
        final tempDir = Directory.systemTemp.createTempSync();
        addTearDown(() => tempDir.deleteSync(recursive: true));
        lockFilePath = p.join(tempDir.path, 'pubspec.lock');
        when(() => dependencies.baseUrl).thenReturn('https://pub.dev');
        when(() => dependencies.globalLockFilePath).thenReturn(lockFilePath);
        httpClient = _MockHttpClient();
        when(() => dependencies.httpClient).thenReturn(httpClient);
        logger = _MockLogger();
        when(() => dependencies.logger).thenReturn(logger);
        when(() => dependencies.rawDartVersion).thenReturn('3.6.0');
      });

      test(
          'prompts the user to update the package '
          'if there is a compatible newer version', () async {
        File(lockFilePath).writeAsStringSync('''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  p1:
    dependency: transitive
    description:
      name: p1
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  coverde:
    dependency: "direct main"
    description:
      name: coverde
      url: "https://pub.dev"
    source: hosted
    version: "0.2.0+1"
  p2:
    dependency: transitive
    description:
      name: p2
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
sdks:
  dart: ">=3.6.0 <4.0.0"
''');
        when(() => httpClient.get(any())).thenAnswer(
          (_) => Future.delayed(
            const Duration(milliseconds: 150),
            () async => http.Response(
              '''
{
  "name": "coverde",
  "versions": [
    {
      "version": "0.1.0",
      "pubspec": {
        "environment": {
          "sdk": ">=2.14.4 <3.0.0"
        }
      }
    },
    {
      "version": "0.1.0+1",
      "pubspec": {
        "environment": {
          "sdk": ">=2.14.4 <3.0.0"
        }
      }
    },
    {
      "version": "0.2.0",
      "retracted": true,
      "pubspec": {
        "environment": {
          "sdk": ">=3.0.0 <4.0.0"
        }
      }
    },
    {
      "version": "0.2.0+1",
      "retracted": true,
      "pubspec": {
        "environment": {
          "sdk": ">=3.0.0 <4.0.0"
        }
      }
    },
    {
      "version": "0.2.0+2",
      "pubspec": {
        "environment": {
          "sdk": ">=3.0.0 <4.0.0"
        }
      }
    }
  ]
}
            ''',
              HttpStatus.ok,
            ),
          ),
        );
        final progress = _MockProgress();
        when(() => logger.progress(any())).thenReturn(progress);
        await packageVersionManager.promptUpdate();
        verify(
          () => logger.write(
            '''
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃                                                           ┃
┃         ${lightYellow.wrap('A new version of `coverde` is available!')}          ┃
┃                     ${lightGray.wrap('0.2.0+1')} \u2192 ${lightGreen.wrap('0.2.0+2')}                     ┃
┃  Run ${wrapWith('dart pub global activate coverde 0.2.0+2', [
                  lightCyan,
                  styleBold,
                ])} to update.  ┃
┃                                                           ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
''',
          ),
        ).called(1);
      });

      test(
          'alerts the user '
          'if there is an error while retrieving the global package '
          'installation info', () async {
        if (File(lockFilePath) case final file when file.existsSync()) {
          // Simulate absent global lock file.
          file.deleteSync();
        }
        final progress = _MockProgress();
        when(() => logger.progress(any())).thenReturn(progress);

        // Workaround to verify different logging methods are called.
        var errCalls = 0;
        when(() => logger.err(any())).thenAnswer((_) => errCalls++);
        var warnCalls = 0;
        when(() => logger.warn(any())).thenAnswer((_) => warnCalls++);

        await packageVersionManager.promptUpdate();
        expect(errCalls + warnCalls, 1);
        verify(() => logger.alert('Failed to prompt update')).called(1);
      });

      test(
          'alerts the user '
          'if there is an error while retrieving the remote package '
          'versioning infos', () async {
        File(lockFilePath).writeAsStringSync('''
packages:
  coverde:
    dependency: "direct main"
    description:
      name: coverde
      url: "https://pub.dev"
    source: hosted
    version: "0.2.0+1"
sdks:
  dart: ">=3.6.0 <4.0.0"
''');
        when(() => httpClient.get(any())).thenThrow(Exception('Test error'));
        final progress = _MockProgress();
        when(() => logger.progress(any())).thenReturn(progress);

        // Workaround to verify different logging methods are called.
        var errCalls = 0;
        when(() => logger.err(any())).thenAnswer((_) => errCalls++);
        var warnCalls = 0;
        when(() => logger.warn(any())).thenAnswer((_) => warnCalls++);

        await packageVersionManager.promptUpdate();
        verify(() => logger.alert('Failed to prompt update')).called(1);
      });

      test(
          'alerts the user '
          'if there is an unexpected error while prompting update', () async {
        File(lockFilePath).writeAsStringSync('''
packages:
  coverde:
    dependency: "direct main"
    description:
      name: coverde
      url: "https://pub.dev"
    source: hosted
    version: "0.2.0+1"
sdks:
  dart: ">=3.6.0 <4.0.0"
''');
        when(() => logger.progress(any())).thenThrow(Exception('Test error'));
        await packageVersionManager.promptUpdate();
        verify(
          () => logger.alert(
            'Unexpected error while prompting update.\n'
            '${Exception('Test error')}',
          ),
        ).called(1);
        verify(() => logger.alert('Failed to prompt update')).called(1);
      });

      test(
          'warns the user '
          'if no compatible newer version is available', () async {
        File(lockFilePath).writeAsStringSync('''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  coverde:
    dependency: "direct main"
    description:
      name: coverde
      url: "https://pub.dev"
    source: hosted
    version: "0.2.0"
sdks:
  dart: ">=3.6.0 <4.0.0"
''');
        when(() => httpClient.get(any())).thenAnswer(
          (_) => Future.delayed(
            const Duration(milliseconds: 150),
            () async => http.Response(
              '''
{
  "name": "coverde",
  "versions": [
    {
      "version": "0.1.0",
      "pubspec": {
        "environment": {
          "sdk": ">=3.0.0 <4.0.0"
        }
      }
    },
    {
      "version": "0.2.0",
      "retracted": true,
      "pubspec": {
        "environment": {
          "sdk": ">=3.0.0 <4.0.0"
        }
      }
    },
    {
      "version": "0.3.0",
      "pubspec": {
        "environment": {
          "sdk": ">=4.0.0 <5.0.0"
        }
      }
    }
  ]
}
            ''',
              HttpStatus.ok,
            ),
          ),
        );
        final progress = _MockProgress();
        when(() => logger.progress(any())).thenReturn(progress);
        await packageVersionManager.promptUpdate();
        verify(
          () => logger.warn(
            'No newer compatible version of `coverde` is available.',
          ),
        ).called(1);
      });
    });
  });

  group('$PackageVersionManager$Logger', () {
    late Logger logger;

    setUp(() {
      logger = _MockLogger();
    });

    group('logGlobalPackageInstallationInfoRetrievalFailure', () {
      test('logs a $AbsentGlobalLockFileForGlobalInstallationFailure', () {
        logger.logGlobalPackageInstallationInfoRetrievalFailure(
          AbsentGlobalLockFileForGlobalInstallationFailure(
            lockFile: File('some/path/to/pubspec.lock'),
          ),
        );
        verify(
          () => logger.warn(
            'Absent global lock file (`some/path/to/pubspec.lock`). '
            'It is likely `dart pub global activate` '
            'was not used to install the package.',
          ),
        ).called(1);
      });

      group('logs a $InvalidGlobalLockFileContentForGlobalInstallationFailure',
          () {
        test('logs a $InvalidGlobalLockMemberTypeForGlobalInstallationFailure',
            () {
          logger.logGlobalPackageInstallationInfoRetrievalFailure(
            InvalidGlobalLockMemberTypeForGlobalInstallationFailure(
              lockFile: File('some/path/to/pubspec.lock'),
              key: 'packages',
              expectedType: YamlMap,
              value: '12345',
            ),
          );
          verify(
            () => logger.err(
              'Invalid global lock file content. '
              'The `packages` member is expected to be a `$YamlMap`. '
              'Actual value: `12345`.',
            ),
          ).called(1);
        });

        test('logs a $InvalidGlobalLockMemberValueForGlobalInstallationFailure',
            () {
          logger.logGlobalPackageInstallationInfoRetrievalFailure(
            InvalidGlobalLockMemberValueForGlobalInstallationFailure(
              lockFile: File('some/path/to/pubspec.lock'),
              key: 'packages',
              value: '12345',
            ),
          );
          verify(
            () => logger.err(
              'Invalid global lock file content. '
              'The `packages` member value is '
              'invalid. '
              'Actual value: `12345`.',
            ),
          ).called(1);
          logger.logGlobalPackageInstallationInfoRetrievalFailure(
            InvalidGlobalLockMemberValueForGlobalInstallationFailure(
              lockFile: File('some/path/to/pubspec.lock'),
              key: 'packages',
              value: '12345',
              hint: 'a valid YamlMap',
            ),
          );
          verify(
            () => logger.err(
              'Invalid global lock file content. '
              'The `packages` member value is '
              'expected to be a valid YamlMap. '
              'Actual value: `12345`.',
            ),
          ).called(1);
        });

        test('logs a $NoDirectMainHostedPackageForGlobalInstallationFailure',
            () {
          logger.logGlobalPackageInstallationInfoRetrievalFailure(
            NoDirectMainHostedPackageForGlobalInstallationFailure(
              lockFile: File('some/path/to/pubspec.lock'),
            ),
          );
          verify(
            () => logger.err(
              'Invalid global lock file content. '
              'No direct main hosted package found.',
            ),
          ).called(1);
        });
      });
    });

    group('logRemotePackageVersioningInfosRetrievalFailure', () {
      test('logs a $UnexpectedRemotePackageVersioningInfosRetrievalFailure',
          () {
        logger.logRemotePackageVersioningInfosRetrievalFailure(
          const UnexpectedRemotePackageVersioningInfosRetrievalFailure(),
        );
        verify(
          () => logger.err(
            'Unexpected remote package versioning infos retrieval failure.',
          ),
        ).called(1);
      });

      group('logs a $InvalidRemotePackageVersioningInfoFailure', () {
        test('logs a $InvalidRemotePackageVersioningInfoMemberTypeFailure', () {
          logger.logRemotePackageVersioningInfosRetrievalFailure(
            const InvalidRemotePackageVersioningInfoMemberTypeFailure(
              key: 'versions',
              expectedType: List,
              value: '12345',
            ),
          );
          verify(
            () => logger.err(
              'Invalid remote package versioning info. '
              'The `versions` member is expected to be a `$List`. '
              'Actual value: `12345`.',
            ),
          ).called(1);
        });

        test('logs a $InvalidRemotePackageVersioningInfoMemberValueFailure',
            () {
          logger.logRemotePackageVersioningInfosRetrievalFailure(
            const InvalidRemotePackageVersioningInfoMemberValueFailure(
              key: 'versions',
              value: '12345',
            ),
          );
          verify(
            () => logger.err(
              'Invalid remote package versioning info. '
              'The `versions` member value is '
              'invalid. '
              'Actual value: `12345`.',
            ),
          ).called(1);
          logger.logRemotePackageVersioningInfosRetrievalFailure(
            const InvalidRemotePackageVersioningInfoMemberValueFailure(
              key: 'versions',
              value: '12345',
              hint: 'a valid List',
            ),
          );
          verify(
            () => logger.err(
              'Invalid remote package versioning info. '
              'The `versions` member value is '
              'expected to be a valid List. '
              'Actual value: `12345`.',
            ),
          ).called(1);
        });
      });
    });
  });
}
